cat /proc/version 	Узнать версию юниха
=====================
cd /home    перейти в директорию '/home'
cd ..       перейти в директорию уровнем выше
cd ../..    перейти в директорию двумя уровнями выше
cd          перейти в домашнюю директорию
cd ~user    перейти в домашнюю директорию пользователя user
cd -        перейти в директорию, в которой находились до перехода в текущую директорию
pwd         показать текущюю директорию
cd prod dev	переход из текущей /opt/prod/bin в /opt/dev/bin
=================
ls          отобразить содержимое текущей директории
ls -F       отобразить содержимое текущей директории с добавлением к именам символов, храктеризующих тип
ls -l       показать детализированое представление файлов и директорий в текущей директории
ls -a       показать скрытые файлы и директории в текущей директории
ls *[0-9]*  показать файлы и директории содержащие в имени цифры
tree        показать дерево файлов и директорий, начиная от корня (/)
lstree
=================
mkdir dir1	создать директорию с именем 'dir1'
mkdir dir1 dir2	создать две директории одновременно
mkdir -p /tmp/dir1/dir2	создать дерево директорий
rm -f file1	удалить файл с именем 'file1'
rmdir dir1	удалить директорию с именем 'dir1'
rm -rf dir1	удалить директорию с именем 'dir1' и рекурсивно всё её содержимое
rm -rf dir1 dir2	удалить две директории и рекурсивно их содержимое
mv dir1 new_dir	переименовать или переместить файл или директорию
cp file1 file2	сопировать файл file1 в файл file2
cp dir/* .	копировать все файлы директории dir в текущую директорию
cp -a /tmp/dir1 .	копировать директорию dir1 со всем содержимым в текущую директорию
cp -a dir1 dir2	копировать директорию dir1 в директорию dir2
ln -s file1 lnk1	создать символическую ссылку на файл или директорию
ln file1 lnk1	создать "жёсткую" (физическую) ссылку на файл или директорию
touch -t 0712250000 fileditest	модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)
=====================
Поиск файлов

find / -name file1	найти файлы и директории с именем file1. Поиск начать с корня (/)
find / -user user1	найти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)
find /home/user1 -name "*.bin"	Найти все файлы и директории, имена которых оканчиваются на '. bin'. Поиск начать с '/ home/user1'
find /usr/bin -type f -atime +100	найти все файлы в '/usr/bin', время последнего обращения к которым  более 100 дней
find /usr/bin -type f -mtime -10	найти все файлы в '/usr/bin', созданные или изменённые в течении последних 10 дней
find / -name *.rpm -exec chmod 755 '{}' \;	найти все фалы и директории, имена которых оканчиваются на '.rpm', и изменить права доступа к ним
find / -xdev -name "*.rpm"	найти все фалы и директории, имена которых оканчиваются на '.rpm', игнорируя съёмные носители, такие как cdrom, floppy и т.п.
locate "*.ps"	найти все файлы, сожержащие в имени '.ps'. Предварительно рекомендуется выполнить команду 'updatedb'
whereis halt	показывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу 'halt'
which halt	отображает полный путь к файлу 'halt'
============================

Дисковое пространство
df -h	
	отображает информацию о смонтированных разделах с отображением общего, доступного и используемого пространства
ls -lSr | more	
	выдаёт список файлов и директорий рекурсивно с сортировкой по возрастанию размера и позволяет осуществлять постраничный просмотр
du -sh dir1	
	подсчитывает и выводит размер, занимаемый директорией 'dir1' 
du -sk * | sort -rn	
	отображает размер и имена файлов и директорий, с соритровкой по размеру
==================
Пользователи и группы
groupadd group_name	создать новую группу с именем group_name
groupdel group_name	удалить группу group_name
groupmod -n new_group_name old_group_name	переименовать группу old_group_name в new_group_name
useradd -c "Nome Cognome" -g admin -d /home/user1 -s /bin/bash user1	создать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome
useradd user1	создать пользователя user1
userdel -r user1	удалить пользователя user1 и его домашний каталог
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1	изменить атрибуты пользователя
passwd	сменить пароль
passwd user1	сменить пароль пользователя user1 (только root)
chage -E 2005-12-31 user1	установить дату окончания действия учётной записи пользователя user1
pwck	проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и /etc/shadow
grpck	проверяет корректность системных файлов учётных записей. Проверяется файл/etc/group
newgrp [-] group_name	изменяет первичную группу текущего пользователя. Если указать "-", ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная группа будет назначена из /etc/passwd
=======================================

Выставление/изменение полномочий на файлы
ls -lh	просмотр полномочий на файлы и директории в текущей директории
ls /tmp | pr -T5 -W$COLUMNS	вывести содержимое директории /tmp и разделить вывод на пять колонок
chmod ugo+rwx directory1	добавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read Write eXecute) - всем полные права. Аналогичное можно сделать таким образом chmod 777 directory1
chmod go-rwx directory1	отобрать у группы и всех остальных все полномочия на директорию directory1.
chown user1 file1	назначить владельцем файла file1 пользователя user1
chown -R user1 directory1	назначить рекурсивно владельцем директории directory1 пользователя user1
chgrp group1 file1	сменить группу-владельца файла file1 на group1
chown user1:group1 file1	сменить владельца и группу владельца файла file1
find / -perm -u+s	найти, начиная от корня, все файлы с выставленным SUID
chmod u+s /bin/binary_file	назначить SUID-бит файлу /bin/binary_file. Это даёт возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла.
chmod u-s /bin/binary_file	снять SUID-бит с файла /bin/binary_file.
chmod g+s /home/public	назначить SGID-бит директории /home/public.
chmod g-s /home/public	снять SGID-бит с директории /home/public.
chmod o+t /home/public	назначить STIKY-бит директории /home/public. Позволяет удалять файлы только владельцам
chmod o-t /home/public	снять STIKY-бит с директории /home/public
==============================
Архивирование и сжатие файлов
bunzip2 file1.bz2	разжимает файл 'file1.gz'
gunzip file1.gz
gzip file1	сжимает файл 'file1'
bzip2 file1
gzip -9 file1	сжать файл file1 с максимальным сжатием
rar a file1.rar test_file	создать rar-архив 'file1.rar' и включить в него файл test_file
rar a file1.rar file1 file2 dir1	создать rar-архив 'file1.rar' и включить в него file1, file2 и dir1
rar x file1.rar	распаковать rar-архив
unrar x file1.rar
tar -cvf archive.tar file1	создать tar-архив archive.tar, содержащий файл file1
tar -cvf archive.tar file1 file2 dir1	создать tar-архив archive.tar, содержащий файл file1, file2 и dir1
tar -tf archive.tar	показать содержимое архива
tar -xvf archive.tar	распаковать архив
tar -xvf archive.tar -C /tmp	распаковать архив в /tmp
tar -cvfj archive.tar.bz2 dir1	создать архив и сжать его с помощью bzip2(Прим.переводчика. ключ -j работает не во всех *nix системах)
tar -xvfj archive.tar.bz2	разжать архив и распаковать его(Прим.переводчика. ключ -j работает не во всех *nix системах)
tar -cvfz archive.tar.gz dir1	создать архив и сжать его с помощью gzip
tar -xvfz archive.tar.gz	разжать архив и распаковать его
zip file1.zip file1	создать сжатый zip-архив
zip -r file1.zip file1 file2 dir1	создать сжатый zip-архив и со включением в него нескольких файлов и/или директорий
unzip file1.zip	разжать и распаковать zip-архив

=======================================
Просмотр содержимого файлов

cat file1	вывести содержимое файла file1 на стандартное устройсво вывода
tac file1	вывести содержимое файла file1 на стандартное устройсво вывода в обратном порядке
more file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода
less file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.
head -2 file1	вывести первые две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
tail -2 file1	вывести последние две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
tail -f /var/log/messages	выводить содержимое файла /var/log/messages на стандартное устройство вывода по мере появления в нём текста.
================================
Манипуляции с текстом

cat file_originale | [operation: sed, grep, awk, grep и т.п.] > result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в новый
cat file_originale | [operazione: sed, grep, awk, grepи т.п.] >> result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он будет создан
sed 's/stringa1/stringa2/g' example.txt	в файле example.txt заменить "string1" на "string2", результат вывести на стандартное устройство вывода.
sed '/^$/d' example.txt	удалить пустые строки из файла example.txt
sed '/ *#/d; /^$/d' example.txt	удалить пустые строки и комментарии из файла example.txt
echo 'esempio' | tr '[:lower:]' '[:upper:]'	преобразовать символы из нижнего регистра в верхний
sed -e '1d' result.txt	удалить первую строку из файла example.txt
sed -n '/string1/p'	отобразить только строки содержашие "string1"
sed -e 's/ *$//' example.txt	удалить пустые символы в в конце каждой строки
sed -e 's/string1//g' example.txt	удалить строку "string1" из текста не изменяя всего остального
sed -n '1,8p;5q' example.txt	взять из файла с первой по восьмую строки и из них вывести первые пять
sed -n '5p;5q' example.txt	вывести пятую строку
sed -e 's/0*/0/g' example.txt	заменить последовательность из любого количества нулей одним нулём
cat -n file1	пронумеровать строки при выводе содержимого файла
cat example.txt | awk 'NR%2==1'	при выводе содержимого файла, не выводить чётные строки файла
echo a b c | awk '{print $1}'	вывести первую колонку. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
echo a b c | awk '{print $1,$3}'	вывести первую и треью колонки. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
paste file1 file2	объединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1 колонка 1-n, строка 1 из file2 = строка 1 колонка n+1-m
paste -d '+' file1 file2	объединить содержимое file1 и file2 в виде таблицы с разделителем "+"
sort file1 file2	отсортировать содержимое двух файлов
sort file1 file2 | uniq	отсортировать содержимое двух файлов, не отображая повторов
sort file1 file2 | uniq -u	отсортировать содержимое двух файлов, отображая только уникальные строки (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)
sort file1 file2 | uniq -d	отсортировать содержимое двух файлов, отображая только повторяющиеся строки
comm -1 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file1'
comm -2 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file2'
comm -3 file1 file2	сравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах
==========================
text file param

kill -9 $(cat /opt/appserv/tomcat/casino.pid)
==============================
grep 'warning\|error\|critical' /var/log/messages
	строки, содержащие несколько слов
grep Aug /var/log/messages	
	строки, содержащие "Aug"
grep ^Aug /var/log/messages
	строки, начинающиеся на "Aug"
grep [0-9] /var/log/messages	
	строки, содержащие цифры
grep Aug -R /var/log/*	
	строки, содержащие "Aug", во всех файлах, находящихся в директории /var/log и ниже
========================
история запущенных команд сохраняется в файле ~/.bash_history.
чтобы команда не записывалась в историю, просто наберите перед командой пробел.
[space] [command]
=========================
utils

mtr [hostname] — мощный инструмент для диагностики сети. Он совмещает в себе функциональность traceroute и ping
w - показывает, кто на данный момент вошел в систему, время работы, нагрузка процессора
factor [number] - раскладывает число на множители
yes [string] - выводит текст несколько раз
nl - нумерует строки. cat [file] | nl

===========================
