\d Любая цифра
\w Алфавитно-цифровой символ
\s Пробельный символ (пробел, табуляция, перевод строки, и т.п.)
\D не цифра
\W не алфавитно-цифровой символ
\S не пробельный символ
. любой символ, кроме перевода строки

==============================
совпадения

console.log(/abc/.test("abcde"));
// true
console.log(/abc/.test("abxde"));
// false

===============================
набор символов

console.log(/[0123456789]/.test("in 1992"));
// true
console.log(/[0-9]/.test("in 1992"));
// true

========================
дата

var dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("30-01-2003 15:20"));
// true
console.log(dateTime.test("30-jan-2003 15:20"));
// false
=========================
[\d.] означает любую цифру или точку. 
Заметьте, что точка внутри квадратных скобок теряет своё особое значение и превращается просто в точку. 
То же касается и других специальных символов, типа +.
========================================
Инвертировать набор символов – сказать, что вам надо найти любой символ, кроме тех, что есть в наборе
 – можно, поставив знак ^ сразу после открывающей квадратной скобки.

var notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// false
console.log(notBinary.test("1100100010200110"));
// true
================================
Если поставить после чего-либо в регулярке знак +, это будет означать, что этот елемент может быть повторён более одного раза. 
\d+ означает одну или несколько цифр.
У звёздочки * значение почти такое же, но она разрешает шаблону присутствовать ноль раз. 
Если после чего-то стоит звёздочка, то оно никогда не препятствует нахождению шаблона в строке – оно просто находится там ноль раз.

console.log(/'\d+'/.test("'123'"));
// true
console.log(/'\d+'/.test("''"));
// false
console.log(/'\d*'/.test("'123'"));
// true
console.log(/'\d*'/.test("''"));
// true
============================

Знак вопроса делает часть шаблона необязательной, то есть она может встретиться ноль или один раз. 
В следующем примере символ u может встречаться, но шаблон совпадает и тогда, когда его нет.

var neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// true
console.log(neighbor.test("neighbor"));
// true
===========================================
Можно использовать промежутки с открытым концом, опуская одно из чисел. 
{,5} означает, что шаблон может встретиться от нуля до пяти раз, а {5,} – от пяти и более.


var dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("30-1-2003 8:45"));
// true
=============================
Группировка

Чтобы использовать операторы * или + на нескольких элементах сразу, можно использовать круглые скобки. 
Часть регулярки, заключённая в скобки, считается одним элементом с точки зрения операторов.

var cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// true


Первый и второй плюсы относятся только ко вторым буквам о в словах boo и hoo. 
Третий + относится к целой группе (hoo+), находя одну или несколько таких последовательностей.
Буква i в конце выражения делает регулярку нечувствительной к регистру симолов – так, что B совпадает с b.


================================

var match = /\d+/.exec("one two 100");
console.log(match);
// ["100"]
console.log(match.index);
// 8
=====================================
Группировка

var quotedText = /'([^']*)'/;
console.log(quotedText.exec("she said 'hello'"));
// ["'hello'", "hello"]
=====================
граница строка

Если нам надо принудить совпадение взять всю строку целиком, мы используем метки ^ и $. 
^ совпадает с началом строки, а $ с концом. 
^\d+$ совпадает со строкой, состоящей только из одной или нескольких цифр
^! совпадает со сторокой, начинающейся с восклицательного знака
x^ не совпадает ни с какой строчкой (перед началом строки не может быть x)

==================================
граница слово

мы используем метку \b
Границей слова может быть начало или конец строки, или любое место строки, где с одной стороны стоит алфавитно-цифровой символ \w, а с другой – не алфавитно-цифровой.

console.log(/cat/.test("concatenate"));
// true
console.log(/\bcat\b/.test("concatenate"));
// false
=======================
Символ | обозначает выбор между шаблонами слева и справа от него.

var animalCount = \b\d+ (pig|cow|chicken)s?\b
console.log(animalCount.test("15 pigs"));
// true
console.log(animalCount.test("15 pigchickens"));
// false


Скобки ограничивают часть шаблона, к которой применяется |, и можно поставить много таких операторов друг за другом, чтобы обозначить выбор из более чем двух вариантов.
==============================
алгоритм
href=habrahabr.ru/post/242695/

проверка регулярки \b\d+ (pig|cow|chicken)s?\b в строке «the 3 pigs» при прохождении по блок-схеме image=3pigs.png выглядит так:

— на позиции 4 есть граница слова, и проходим первый прямоугольник
— начиная с 4 позиции находим цифру, и проходим второй прямоугольник
— на позиции 5 один путь замыкается назад перед вторым прямоугольником, а второй проходит далее к прямоугольнику с пробелом. У нас пробел, а не цифра, и мы выбираем второй путь.
— теперь мы на позиции 6, начало “pigs”, и на тройном разветвлении путей. В строке нет “cow” или “chicken”, зато есть “pig”, поэтому мы выбираем этот путь.
— на позиции 9 после тройного разветвления, один путь обходит “s” и направляется к последнему прямоугольнику с границей слова, а второй проходит через “s”. У нас есть “s”, поэтому мы идём туда.
— на позиции 10 мы в конце строки, и совпасть может только граница слова. Конец строки считается границей, и мы проходим через последний прямоугольник. И вот мы успешно нашли наш шаблон.


начинает в начале строки и пытается найти совпадение там
двигается ко второму символу в строке, и пытается найти совпадение там… 
И так далее, пока он не находит совпадение или не доходит до конца строки, в каком случае совпадение на найдено.
================================
Откат

Регулярка /\b([01]+b|\d+|[\da-f]h)\b/ совпадает либо с двоичным числом, за которым следует b, либо с десятичным числом без суффикса, либо шестнадцатеричным (цифры от 0 до 9 или символы от a до h), за которым идёт h. 
Соответствующая диаграмма: image=binary.png

В поисках совпадения может случиться, что алгоритм пошёл по верхнему пути (двоичное число), даже если в строке нет такого числа. Если там есть строка “103”, к примеру, понятно, что только достигнув цифры 3 алгоритм поймёт, что он на неправильном пути. Вообще строка совпадает с регуляркой, просто не в этой ветке.

Тогда алгоритм совершает откат. На развилке он запоминает текущее положение (в нашем случае, это начало строки, сразу после границы слова), чтобы можно было вернуться назад и попробовать другой путь, если выбранный не срабатывает. Для строки “103” после встречи с тройкой он вернётся и попытается пройти путь для десятичных чисел. Это сработает, поэтому совпадение будет найдено.

Алгоритм останавливается, как только найдёт полное совпадение. Это значит, что даже если несколько вариантов могут подойти, используется только один из них (в том порядке, в каком они появляются в регулярке).
============================
замена

есть строка, содержащая имена людей, одно имя на строчку, в формате «Фамилия, Имя». 
Если нам надо поменять их местами и убрать запятую, чтобы получилось «Имя Фамилия», мы пишем следующее:

console.log(
  "Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"
    .replace(/([\w ]+), ([\w ]+)/g, "$2 $1"));
// Grace Hopper
// John McCarthy
// Dennis Ritchie
===================================

abc	Последовательность символов
[abc]	Любой символ из списка
[^abc]	Любой символ, кроме символов из списка
[0-9] 	Любой символ из промежутка
x+ 	Одно или более вхождений шаблона x
x+? 	Одно или более вхождений, нежадное
x*	Ноль или более вхождений
x?	Ноль или одно вхождение
x{2,4}	От двух до четырёх вхождений
(abc) 	Группа
a|b|c	Любой из нескольких шаблонов
\b 	Граница слова
^ 	Начало строки
$ 	Конец строки
======================================
отладка

href=debuggex.com
href=regexbuddy.com
href=regexper.com
=================================
